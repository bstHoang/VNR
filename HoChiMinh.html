<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hồ Chí Minh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #game-canvas:active {
            cursor: grabbing;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <button id="open-menu-btn" class="absolute top-6 left-6 md:top-8 md:left-8 z-30 p-3 bg-black/50 rounded-lg backdrop-blur-sm text-white hover:bg-black/70 transition">
        <div class="w-6 h-0.5 bg-white mb-1.5"></div>
        <div class="w-6 h-0.5 bg-white mb-1.5"></div>
        <div class="w-6 h-0.5 bg-white"></div>
    </button>
    <div id="character-menu" 
         class="absolute top-0 left-0 h-full bg-black/70 backdrop-blur-md p-4 shadow-lg z-40
                transform -translate-x-full 
                transition-transform duration-300 ease-in-out
                flex flex-col space-y-4 w-auto">
        
        <button id="close-menu-btn" class="self-end text-white hover:text-gray-300 mb-2 p-2 rounded-full hover:bg-white/10">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
        
        <p class="text-sm font-bold text-center mb-2">CHỌN NHÂN VẬT</p>

        <div class="cursor-pointer p-2 rounded-lg hover:bg-white/20 transition text-center opacity-60 hover:opacity-100">
            <img src="https://placehold.co/64x64/f9f9f9/333?text=NV1" alt="Nhân vật 1" class="w-16 h-16 rounded-full object-cover mx-auto">
            <p class="text-xs mt-1">Võ Nguyên Giáp</p>
        </div>
        
        <div class="cursor-pointer p-2 rounded-lg bg-white/20 transition text-center border-2 border-blue-400">
            <img src="HoChiMinh.jpg" alt="Hồ Chí Minh" class="w-16 h-16 rounded-full object-cover mx-auto">
            <p class="text-xs mt-1 font-bold">Hồ Chí Minh</p>
        </div>

        <div class="cursor-pointer p-2 rounded-lg hover:bg-white/20 transition text-center opacity-60 hover:opacity-100">
            <img src="https://placehold.co/64x64/f9f9f9/333?text=NV2" alt="Nhân vật 3" class="w-16 h-16 rounded-full object-cover mx-auto">
            <p class="text-xs mt-1">Lê Duẩn</p>
        </div>
    </div>
    <canvas id="game-canvas"></canvas>
    
    <div class="absolute top-0 left-0 p-6 md:p-8 text-white w-full z-10 text-center">
        <h1 class="text-2xl md:text-3xl font-bold text-white drop-shadow-lg">Hồ Chí Minh</h1>
    </div>
    
    <div id="detail-panel" class="absolute top-0 right-0 h-full w-1/3 md:w-1/4 bg-black/80 p-6 overflow-y-auto flex flex-col items-center text-white backdrop-blur-md border-l border-white/20 z-30">
        <img src="HoChiMinh.jpg" alt="Hình mẫu" class="w-full h-auto object-contain mb-4 rounded-lg">
        <p class="text-sm text-center">
            Hồ Chí Minh (1890-1969) là một nhà cách mạng vĩ đại, lãnh tụ của dân tộc Việt Nam. Ông đã lãnh đạo nhân dân Việt Nam giành độc lập từ thực dân Pháp và thành lập nước Việt Nam Dân chủ Cộng hòa. Với tư tưởng Hồ Chí Minh, ông nhấn mạnh vào độc lập dân tộc, đoàn kết và xây dựng một xã hội công bằng. Di sản của ông vẫn là nguồn cảm hứng cho nhiều thế hệ.
        </p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // ... (TOÀN BỘ CODE THREE.JS GIỮ NGUYÊN) ...
        // Configuration
        const imageUrl = '1.jpg';
        const DENSITY = 3; // Mật độ hạt
        const BRIGHTNESS_THRESHOLD = 0.4; // Ngưỡng sáng (có thể điều chỉnh nếu shadow chưa khớp)
        const DEPTH_RANGE = 80; // Phạm vi độ sâu (Z)
        const PARTICLE_RADIUS = 1.2; // Bán kính quả cầu
        const SCALE_XY = 2; // Hệ số thu nhỏ trục X và Y
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); // Tăng tầm nhìn xa của camera
        
        // THAY ĐỔI 1: Di chuyển camera ra xa hơn nữa
        camera.position.set(-864, 216, 540); // Vị trí cũ: (-576, 144, 360)
        
        camera.lookAt(0, 0, 0);
        const canvas = document.getElementById('game-canvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x2a2a2a);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8);
        directionalLight.position.set(50, 100, 200);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        
        // THAY ĐỔI 2: Điều chỉnh vùng shadow của đèn để khớp với plane mới (2700x1800)
        const shadowBoundsX = 1350; // 2700 / 2 (Cũ: 900)
        const shadowBoundsY = 900;  // 1800 / 2 (Cũ: 600)
        directionalLight.shadow.camera.left = -shadowBoundsX;
        directionalLight.shadow.camera.right = shadowBoundsX;
        directionalLight.shadow.camera.top = shadowBoundsY;
        directionalLight.shadow.camera.bottom = -shadowBoundsY;

        // Tăng khoảng cách nhìn xa của đèn
        directionalLight.shadow.camera.far = 1000;
        directionalLight.shadow.camera.near = 0.1;
        // Điều chỉnh bias để shadow rõ nét hơn, tránh artifact
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // THAY ĐỔI 3: Tăng kích thước của Plane (nền)
        // Tải texture ảnh nền
        const bgTextureLoader = new THREE.TextureLoader();
        const backgroundTexture = bgTextureLoader.load('Đảng Cộng sản Việt Nam.png'); // Sử dụng ảnh bạn cung cấp

        // Tăng kích thước plane theo tỷ lệ 3:2 của ảnh
        const planeGeometry = new THREE.PlaneGeometry(2700, 1800); // Kích thước cũ: 1800, 1200
        
        // Sử dụng 'map' để áp ảnh làm vật liệu, thay vì 'color'
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            map: backgroundTexture, // Thêm ảnh nền
            roughness: 0.8
        });
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.z = -500; // Giữ nguyên vị trí z
        plane.receiveShadow = true;
        scene.add(plane);

        // Variables
        let particleCloud, particleCount;
        let isDragging = false;
        const previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;
        // Load image and create particle cloud (đảo ngược logic: tạo hạt từ phần tối thay vì sáng)
        const loader = new THREE.TextureLoader();
        loader.load(imageUrl, (texture) => {
            const image = texture.image;
            const imageWidth = image.width;
            const imageHeight = image.height;
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = imageWidth;
            canvas.height = imageHeight;
            context.drawImage(image, 0, 0);
            const imageData = context.getImageData(0, 0, imageWidth, imageHeight).data;
            const validPixels = [];
            for (let i = 0; i < imageData.length; i += 4) {
                const brightness = (imageData[i] + imageData[i+1] + imageData[i+2]) / (255 * 3);
                // Đảo ngược: Tạo hạt từ phần tối (brightness < threshold) thay vì >
                if (brightness < BRIGHTNESS_THRESHOLD && Math.random() < DENSITY) {
                    validPixels.push({
                        x: (i / 4) % imageWidth,
                        y: Math.floor((i / 4) / imageWidth),
                        color: { 
                            r: imageData[i]/255, 
                            g: imageData[i+1]/255, 
                            b: imageData[i+2]/255 
                        },
                        brightness: brightness
                    });
                }
            }
            particleCount = validPixels.length;
            console.log(`Tạo đám mây với ${particleCount} hạt`);
            // Tạo geometry cho mỗi hạt là quả cầu nhỏ (để cast shadow tốt)
            const sphereGeometry = new THREE.SphereGeometry(PARTICLE_RADIUS, 8, 8); // Segments thấp để performance tốt
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.5, // Làm bóng mịn hơn
                metalness: 0.1
            });
            particleCloud = new THREE.InstancedMesh(sphereGeometry, material, particleCount);
            const dummy = new THREE.Object3D();
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const pixelData = validPixels[i];
                const i3 = i * 3;
                // Vị trí X, Y từ ảnh
                const posX = (pixelData.x - imageWidth / 2) * SCALE_XY;
                const posY = -(pixelData.y - imageHeight / 2) * SCALE_XY;
                // Vị trí Z: phân bố dựa trên độ sáng
                // Giữ nguyên depthFactor = 1 - brightness (phần tối có depth lớn hơn)
                // Nếu muốn đảo, đổi thành depthFactor = pixelData.brightness;
                const depthFactor = 1 - pixelData.brightness;
                const posZ = (Math.random() - 0.5) * DEPTH_RANGE * depthFactor;
                // Set matrix cho instance
                dummy.position.set(posX, posY, posZ);
                dummy.updateMatrix();
                particleCloud.setMatrixAt(i, dummy.matrix);
                // Màu sắc
                particleCloud.setColorAt(i, new THREE.Color(pixelData.color.r, pixelData.color.g, pixelData.color.b));
            }
            particleCloud.instanceMatrix.needsUpdate = true;
            particleCloud.instanceColor.needsUpdate = true;
            particleCloud.castShadow = true; // Bật cast shadow cho toàn bộ đám mây
            scene.add(particleCloud);
            // Bắt đầu ở vị trí xoay ngẫu nhiên
            resetRotation();
            animate();
        });
        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !particleCloud) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            const rotationQuaternionY = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 1, 0),
                deltaX * rotationSpeed
            );
            const rotationQuaternionX = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                deltaY * rotationSpeed
            );
            particleCloud.quaternion.multiplyQuaternions(rotationQuaternionY, particleCloud.quaternion);
            particleCloud.quaternion.multiplyQuaternions(rotationQuaternionX, particleCloud.quaternion);
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        // Game logic functions
        function resetRotation() {
            if (!particleCloud) return;
            particleCloud.quaternion.setFromEuler(
                new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                )
            );
        }
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        // Responsive
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', handleResize);

        // --- START: THAY ĐỔI JAVASCRIPT ---

        // Lấy các phần tử mới cho menu bên trái
        const openMenuBtn = document.getElementById('open-menu-btn');
        const closeMenuBtn = document.getElementById('close-menu-btn');
        const characterMenu = document.getElementById('character-menu');
        
        const detailPanel = document.getElementById('detail-panel');
        const closePanelBtn = document.getElementById('close-panel-btn');

        // Gán sự kiện click cho nút mở menu
        openMenuBtn.addEventListener('click', () => {
            characterMenu.classList.remove('-translate-x-full'); // Hiện menu
        });

        // Gán sự kiện click cho nút đóng menu
        closeMenuBtn.addEventListener('click', () => {
            characterMenu.classList.add('-translate-x-full'); // Ẩn menu
        });

        // Xóa bỏ sự kiện click cho targetShape (vì nó đã bị xóa)
        // const targetShape = document.getElementById('target-shape');
        // targetShape.addEventListener('click', () => {
        //     detailPanel.classList.remove('hidden');
        //     detailPanel.classList.add('flex');
        // });

        // Giữ lại sự kiện đóng cho panel chi tiết
        closePanelBtn.addEventListener('click', () => {
            detailPanel.classList.add('hidden');
    
            detailPanel.classList.remove('flex');
        });

        // --- END: THAY ĐỔI JAVASCRIPT ---
    </script>
</body>
</html>