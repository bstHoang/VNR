<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hồ Chí Minh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        #game-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        #game-canvas:active {
            cursor: grabbing;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">
    <canvas id="game-canvas"></canvas>
    <div class="absolute top-0 left-0 p-6 md:p-8 text-white w-full">
        <h1 class="text-2xl md:text-3xl font-bold text-white drop-shadow-lg">Hồ Chí Minh</h1>
    </div>
    <div class="absolute top-6 right-6 md:top-8 md:right-8 bg-white/10 p-4 rounded-xl backdrop-blur-sm border border-white/20">
        <p class="text-center text-xs mb-2 font-bold">XEM THÊM</p>
        <div id="target-shape" class="w-20 h-20 md:w-24 md:h-24 bg-white/5 rounded-lg flex items-center justify-center cursor-pointer hover:bg-white/10 transition">
            <img src="HoChiMinh.jpg" alt="Hình mẫu" class="w-full h-full object-contain">
        </div>
    </div>
    <div id="detail-panel" class="absolute top-0 right-0 h-full w-1/3 md:w-1/4 bg-black/80 p-6 overflow-y-auto hidden flex flex-col items-center text-white backdrop-blur-md border-l border-white/20">
        <button id="close-panel-btn" class="self-end text-white hover:text-gray-300 mb-4">Đóng</button>
        <img src="HoChiMinh.jpg" alt="Hình mẫu" class="w-full h-auto object-contain mb-4 rounded-lg">
        <p class="text-sm text-center">
            Hồ Chí Minh (1890-1969) là một nhà cách mạng vĩ đại, lãnh tụ của dân tộc Việt Nam. Ông đã lãnh đạo nhân dân Việt Nam giành độc lập từ thực dân Pháp và thành lập nước Việt Nam Dân chủ Cộng hòa. Với tư tưởng Hồ Chí Minh, ông nhấn mạnh vào độc lập dân tộc, đoàn kết và xây dựng một xã hội công bằng. Di sản của ông vẫn là nguồn cảm hứng cho nhiều thế hệ.
        </p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        // Configuration
        const imageUrl = '1.jpg';
        const DENSITY = 0.7; // Mật độ hạt
        const BRIGHTNESS_THRESHOLD = 0.4; // Ngưỡng sáng (có thể điều chỉnh nếu shadow chưa khớp)
        const DEPTH_RANGE = 80; // Phạm vi độ sâu (Z)
        const PARTICLE_RADIUS = 1.2; // Bán kính quả cầu
        const SCALE_XY = 1; // Hệ số thu nhỏ trục X và Y
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); // Tăng tầm nhìn xa của camera
        
        // THAY ĐỔI 1: Di chuyển camera ra xa hơn nữa
        camera.position.set(-500, 216, 540); // Vị trí cũ: (-576, 144, 360)
        
        camera.lookAt(0, 0, 0);
        const canvas = document.getElementById('game-canvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x2a2a2a);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8);
        directionalLight.position.set(50, 100, 200);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        
        // THAY ĐỔI 2: Điều chỉnh vùng shadow của đèn để khớp với plane mới (2700x1800)
        const shadowBoundsX = 1350; // 2700 / 2 (Cũ: 900)
        const shadowBoundsY = 900;  // 1800 / 2 (Cũ: 600)
        directionalLight.shadow.camera.left = -shadowBoundsX;
        directionalLight.shadow.camera.right = shadowBoundsX;
        directionalLight.shadow.camera.top = shadowBoundsY;
        directionalLight.shadow.camera.bottom = -shadowBoundsY;

        // Tăng khoảng cách nhìn xa của đèn
        directionalLight.shadow.camera.far = 1000;
        directionalLight.shadow.camera.near = 0.1;
        // Điều chỉnh bias để shadow rõ nét hơn, tránh artifact
        directionalLight.shadow.bias = -0.0001;
        scene.add(directionalLight);

        // THAY ĐỔI 3: Tăng kích thước của Plane (nền)
        // Tải texture ảnh nền
        const bgTextureLoader = new THREE.TextureLoader();
        const backgroundTexture = bgTextureLoader.load('Đảng Cộng Sản Việt Nam.png'); // Sử dụng ảnh bạn cung cấp

        // Tăng kích thước plane theo tỷ lệ 3:2 của ảnh
        const planeGeometry = new THREE.PlaneGeometry(2700, 1800); // Kích thước cũ: 1800, 1200
        
        // Sử dụng 'map' để áp ảnh làm vật liệu, thay vì 'color'
        const planeMaterial = new THREE.MeshStandardMaterial({ 
            map: backgroundTexture, // Thêm ảnh nền
            roughness: 0.8
        });
        
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.position.z = -250; // Giữ nguyên vị trí z
        plane.receiveShadow = true;
        scene.add(plane);

        // Variables
        let particleCloud, particleCount;
        let isDragging = false;
        const previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;
        // Load image and create particle cloud (đảo ngược logic: tạo hạt từ phần tối thay vì sáng)
        const loader = new THREE.TextureLoader();
        loader.load(imageUrl, (texture) => {
            const image = texture.image;
            const imageWidth = image.width;
            const imageHeight = image.height;
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d', { willReadFrequently: true });
            canvas.width = imageWidth;
            canvas.height = imageHeight;
            context.drawImage(image, 0, 0);
            const imageData = context.getImageData(0, 0, imageWidth, imageHeight).data;
            const validPixels = [];
            for (let i = 0; i < imageData.length; i += 4) {
                const brightness = (imageData[i] + imageData[i+1] + imageData[i+2]) / (255 * 3);
                // Đảo ngược: Tạo hạt từ phần tối (brightness < threshold) thay vì >
                if (brightness < BRIGHTNESS_THRESHOLD && Math.random() < DENSITY) {
                    validPixels.push({
                        x: (i / 4) % imageWidth,
                        y: Math.floor((i / 4) / imageWidth),
                        color: { 
                            r: imageData[i]/255, 
                            g: imageData[i+1]/255, 
                            b: imageData[i+2]/255 
                        },
                        brightness: brightness
                    });
                }
            }
            particleCount = validPixels.length;
            console.log(`Tạo đám mây với ${particleCount} hạt`);
            // Tạo geometry cho mỗi hạt là quả cầu nhỏ (để cast shadow tốt)
            const sphereGeometry = new THREE.SphereGeometry(PARTICLE_RADIUS, 8, 8); // Segments thấp để performance tốt
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.5, // Làm bóng mịn hơn
                metalness: 0.1
            });
            particleCloud = new THREE.InstancedMesh(sphereGeometry, material, particleCount);
            const dummy = new THREE.Object3D();
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const pixelData = validPixels[i];
                const i3 = i * 3;
                // Vị trí X, Y từ ảnh
                const posX = (pixelData.x - imageWidth / 2);
                const posY = -(pixelData.y - imageHeight / 2);
                // Vị trí Z: phân bố dựa trên độ sáng
                // Giữ nguyên depthFactor = 1 - brightness (phần tối có depth lớn hơn)
                // Nếu muốn đảo, đổi thành depthFactor = pixelData.brightness;
                const depthFactor = 1 - pixelData.brightness;
                const posZ = (Math.random() - 0.5) * DEPTH_RANGE * depthFactor;
                // Set matrix cho instance
                dummy.position.set(posX, posY, posZ);
                dummy.updateMatrix();
                particleCloud.setMatrixAt(i, dummy.matrix);
                // Màu sắc
                particleCloud.setColorAt(i, new THREE.Color(pixelData.color.r, pixelData.color.g, pixelData.color.b));
            }
            particleCloud.instanceMatrix.needsUpdate = true;
            particleCloud.instanceColor.needsUpdate = true;
            particleCloud.castShadow = true; // Bật cast shadow cho toàn bộ đám mây
            scene.add(particleCloud);
            // Bắt đầu ở vị trí xoay ngẫu nhiên
            resetRotation();
            animate();
        });
        // Mouse controls
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !particleCloud) return;
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            const rotationQuaternionY = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 1, 0),
                deltaX * rotationSpeed
            );
            const rotationQuaternionX = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                deltaY * rotationSpeed
            );
            particleCloud.quaternion.multiplyQuaternions(rotationQuaternionY, particleCloud.quaternion);
            particleCloud.quaternion.multiplyQuaternions(rotationQuaternionX, particleCloud.quaternion);
            previousMousePosition.x = e.clientX;
            previousMousePosition.y = e.clientY;
        });
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        // Game logic functions
        function resetRotation() {
            if (!particleCloud) return;
            particleCloud.quaternion.setFromEuler(
                new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                )
            );
        }
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        // Responsive
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', handleResize);
        // Xử lý click vào target-shape và panel
        const targetShape = document.getElementById('target-shape');
        const detailPanel = document.getElementById('detail-panel');
        const closePanelBtn = document.getElementById('close-panel-btn');
        targetShape.addEventListener('click', () => {
            detailPanel.classList.remove('hidden');
            detailPanel.classList.add('flex');
        });
        closePanelBtn.addEventListener('click', () => {
            detailPanel.classList.add('hidden');
            detailPanel.classList.remove('flex');
        });
    </script>
</body>
</html>